<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON from GitHub</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>
<body>
    <div id="myMap" style="height: 600px;"></div>
    <script>
        const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        });

        var map = L.map('myMap', {
            center: [35.1, 136.9],import requests
import xml.etree.ElementTree as ET
import geojson
from datetime import datetime

# 地震観測点の位置情報を含むGeoJSONファイルのパス
geojson_path = "/content/drive/MyDrive/AI/Earthquake/stations.geojson"

# GeoJSONファイルの読み込み
with open(geojson_path, "r", encoding="utf-8") as f:
    geojson_data = geojson.load(f)

# GeoJSONの観測点データを辞書に変換（station_nameをキーとする）
station_data = {}
for feature in geojson_data['features']:
    station_name = feature['properties']['station_name']
    station_data[station_name] = feature

# XMLデータのURLを設定
xml_url = "https://www.data.jma.go.jp/developer/xml/feed/eqvol.xml"
print("XMLデータのURLを設定しました。")

# XMLデータの取得
response = requests.get(xml_url)
response.encoding = response.apparent_encoding
xml_data = response.text
print("XMLデータを取得しました。")

# XMLデータの解析
root = ET.fromstring(xml_data)
print("XMLデータを解析しました。")

# 名前空間の設定
namespace = {'atom': 'http://www.w3.org/2005/Atom'}

# <entry>タグで地震情報を取得
entries = root.findall("atom:entry", namespace)
print(f"取得したentryの数: {len(entries)}")

for entry in entries:
    title = entry.find("atom:title", namespace).text
    link = entry.find("atom:link", namespace).get('href')
    
    # 「震源・震度に関する情報」のみを処理対象とする
    if "震源・震度に関する情報" not in title:
        continue

    print(f"処理中の情報: {title} - リンク: {link}")

    # 地震情報の詳細取得
    detail_response = requests.get(link)
    detail_response.encoding = detail_response.apparent_encoding
    detail_xml_data = detail_response.text

    # 詳細情報のXML解析
    detail_root = ET.fromstring(detail_xml_data)

    # 名前空間を追加して、Body内の情報を取得
    detail_namespace = {
        'jmx': 'http://xml.kishou.go.jp/jmaxml1/',
        'info': 'http://xml.kishou.go.jp/jmaxml1/informationBasis1/',
        'seis': 'http://xml.kishou.go.jp/jmaxml1/body/seismology1/',
        'elem': 'http://xml.kishou.go.jp/jmaxml1/elementBasis1/'
    }

    # OriginTimeの取得
    origin_time_element = detail_root.find(".//seis:OriginTime", detail_namespace)
    if origin_time_element is not None:
        origin_time_str = origin_time_element.text
        # yyyy-mm-ddThh:mm:ss+09:00 -> yyyymmdd-hhmm
        origin_time = datetime.fromisoformat(origin_time_str)
        report_datetime_formatted = origin_time.strftime("%Y%m%d-%H%M")
    else:
        report_datetime_formatted = "unknown"

    # 最大震度の取得
    max_intensity_element = detail_root.find(".//seis:MaxInt", detail_namespace)
    if max_intensity_element is not None:
        max_intensity = max_intensity_element.text
        print(f"最大震度: {max_intensity}")
    else:
        max_intensity = "unknown"
        print("最大震度情報が見つかりませんでした。")

    # 震度2以上の観測地点情報を抽出
    observation_points = []
    for area in detail_root.findall(".//seis:Pref", detail_namespace):
        pref_name = area.find("seis:Name", detail_namespace).text
        for city in area.findall(".//seis:City", detail_namespace):
            city_name = city.find("seis:Name", detail_namespace).text
            for intensity_station in city.findall(".//seis:IntensityStation", detail_namespace):
                station_name = intensity_station.find("seis:Name", detail_namespace).text
                intensity_value = intensity_station.find("seis:Int", detail_namespace).text
                # 震度2以上を含む
                if intensity_value in ["1", "2", "3", "4", "5-", "5+", "6-", "6+", "7"]:
                    if station_name in station_data:
                        # GeoJSONに震度情報を追加
                        station_feature = station_data[station_name]
                        station_feature['properties']['intensity'] = intensity_value
                        station_feature['properties']['earthquake_time'] = report_datetime_formatted
                        observation_points.append(station_feature)

    # 結果を1行にまとめて出力
    if observation_points:
        # ファイル名をOriginTimeに基づいて生成する
        filename = f"{report_datetime_formatted}_combined.geojson"

        # 更新されたGeoJSONファイルの保存
        updated_geojson = geojson.FeatureCollection(observation_points)
        with open(filename, "w", encoding="utf-8") as geojson_file:
            geojson.dump(updated_geojson, geojson_file, ensure_ascii=False, indent=2)

        print(f"{title} ({report_datetime_formatted}, 最大震度: {max_intensity}) の更新されたGeoJSONファイルが生成されました: {filename}（観測点数: {len(observation_points)}）")
    else:
        print(f"{title} ({report_datetime_formatted}, 最大震度: {max_intensity}) は震度2以上の観測情報がありませんでした。ファイルは生成されません。")

            zoom: 6,
            layers: [osm]
        });

        const repoOwner = 'hasshi3';
        const repoName = 'earthquake_intensity';

        // ベースマップとオーバーレイマップの設定
        var baseMaps = {
            "OpenStreetMap": osm
        };

        var overlayMaps = {};

        // レイヤーコントロールを一度だけ初期化
        var layerControl = L.control.layers(baseMaps, overlayMaps, { collapsed: false }).addTo(map);

        // GitHub APIを使用してリポジトリ内の.geojsonファイルを取得
        fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/contents`)
            .then(response => response.json())
            .then(files => {
                files
                    .filter(file => file.name.endsWith('.geojson'))
                    .forEach(file => {
                        fetch(file.download_url)
                            .then(response => response.json())
                            .then(geojson => {
                                const layer = L.geoJSON(geojson, {
                                    onEachFeature: function(feature, layer) {
                                        if (feature.properties && feature.properties.station_name) {
                                            layer.bindPopup(feature.properties.station_name);
                                        }
                                    },
                                    pointToLayer: function(feature, latlng) {
                                        return L.circleMarker(latlng, styles(feature));
                                    },
                                    style: styles
                                });

                                // 各GeoJSONファイルをレイヤーコントロールに追加
                                overlayMaps[file.name] = layer;
                                layerControl.addOverlay(layer, file.name);
                                layer.addTo(map);
                            })
                            .catch(error => console.error('Error loading GeoJSON:', error));
                    });
            })
            .catch(error => console.error('Error fetching file list from GitHub:', error));

        function styles(feature) {
            let intensityColor;
            if (feature.properties && feature.properties.intensity) {
                switch (feature.properties.intensity) {
                    case "1": intensityColor = "green"; break;
                    case "2": intensityColor = "yellow"; break;
                    case "3": intensityColor = "orange"; break;
                    case "4": intensityColor = "red"; break;
                    default: intensityColor = "#ff7800"; // デフォルト色
                }
            } else {
                intensityColor = "#ff7800"; // デフォルト色
            }

            switch (feature.geometry.type) {
                case "Point": return {
                    radius: 8,
                    fillColor: intensityColor,
                    color: "#000",
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.6,
                };
                case "LineString": return {
                    color: "#4f6bdb",
                    lineCap: 'square',
                    weight: 5,
                    opacity: .8
                };
                case "Polygon": return {
                    color: "#34ccea8b",
                    fillColor: "#ea3483"
                };
                default: return {};
            }
        }
    </script>
</body>
</html>

